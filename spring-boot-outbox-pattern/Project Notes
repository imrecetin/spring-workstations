Event Sourcing, CQRS, CDC, and Outbox
Event Sourcing and Change Data Capture are solutions that can be used to build distributed systems (i.e. microservices) that are Reactive
Microservices should react to an ever-changing environment (i.e. the cloud) by being resilient and elastic.
The magic behind these abilities is being message and event driven
  1. Designate one datastore as the global source of truth for a specific set of data
  2. Provide a representation of past and current application state as a series of events, also called a journal or transaction log
  3. Offer a journal that can replay events, as needed, for rebuilding or refreshing state

* Domain events — An explicit event, part of your business domain, that is generated by your application.
  These events are usually represented in the past tense, such as OrderPlaced, or ItemShipped.
  These events are the primary concern for Event Sourcing.
* Change events — Events that are generated from a database transaction log indicating what state transition has occurred.
  These events are of concern for Change Data Capture.

Domain events and change events are not related unless a change event happens to contain a domain event,
which is a premise for the Outbox Pattern to be introduced later in the article.

The primary goal of the Outbox Pattern is to ensure that updates to the application state (stored in tables)
and publishing of the respective domain event is done within a single transaction.

Here are the common attributes that exist between an Event Sourcing journal and an Outbox:
  Event ID — Unique identifier for the event itself and can be used for de-duplication for idempotent consumers
  Aggregate ID — Unique identifier used to partition related events; these events compose an Aggregate’s state
  Aggregate Type — The type of the Aggregate that can be used for routing of events only to interested consumers
  Sequence/Timestamp — A way to sort events to provide ordering guarantees
  Message Payload — Contains the event data to be exchanged in a format readable by downstream consumers

The major difference is that the Event Sourcing journal is meant to be a permanent and immutable store of domain events,
while the Outbox is meant to be highly ephemeral and only be a landing zone for domain events to be captured inside
change events and forwarded to downstream consumers.

Debezium is an open source CDC project supported by Red Hat that has gradually gained popularity over the past few years.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------
https://debezium.io/blog/2019/02/19/reliable-microservices-data-exchange-with-the-outbox-pattern/

you’ll probably agree that the hardest part about them is data: microservices don’t exist in isolation and very often
they need to propagate data and data changes amongst each other.

Durable logs also support re-playability, i.e. new consumers can be added as needed, enabling use cases you might not
have had in mind originally, and without touching the source service. E.g. consider a data warehouse which should keep
information about all the orders ever placed, or some full-text search functionality on purchase orders based on Elasticsearch.
Once the purchase order events are in a Kafka topic (Kafka’s topic’s retention policy settings can be used to ensure
that events remain in a topic as long as its needed for the given use cases and business requirements), new consumers can subscribe,
process the topic from the very beginning and materialize a view of all the data in a microservice’s database, search index, data warehouse etc.

Besides using CDC for updating caches, services and search engines,
Data replication. Commonly used for replication of data into another type of database or data warehouse.
Auditing. By keeping the history of events, possibly after enriching each event with metadata,
you will have an audit of all changes made. One example of metadata that may be interesting is the current user.

Debezium tails the transaction log ("write-ahead log", WAL) of the order service’s Postgres database in order to capture
any new events in the outbox table and propagates them to Apache Kafka.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------
